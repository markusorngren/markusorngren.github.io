<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js').then(reg => {
                const askVersion = (worker) => {
                    if (!worker) return;
                    const msgChan = new MessageChannel();
                    msgChan.port1.onmessage = (event) => {
                        if (event.data && event.data.version) {
                            document.getElementById('version-tag').innerText = event.data.version.toUpperCase();
                        }
                    };
                    worker.postMessage({ type: 'GET_VERSION' }, [msgChan.port2]);
                };
                if (reg.active) askVersion(reg.active);
                reg.addEventListener('updatefound', () => {
                    const newWorker = reg.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'activated') askVersion(newWorker);
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            window.location.reload();
                        }
                    });
                });
            });
        });
    }

    let map, targetMarker, userMarker, connectionLine, userCoords;
    let currentTargetCoords = null;
    let waypoints = []; 
    let waypointMarkers = []; 
    let startCoords = null;
    let currentTargetName = "M√ÖLET";
    let initialZoomPerformed = false; 
    let isTracking = false; 
    let isShowingUser = true;
    let savedLocations = JSON.parse(localStorage.getItem('mouse_favs')) || [null, null, null, null];
    let wakeLock = null;
    let currentRouteCoords = []; 
    let travelMode = 0; 

    const modes = [
        { icon: 'üöó', factor: 1.0, osrm: 'car' },
        { icon: 'üö∂', factor: 0.1, osrm: 'foot' },
        { icon: 'üö∂‚ÜîÔ∏è', factor: 0.1, osrm: 'foot' } 
    ];

    let lastTargetRaw = JSON.parse(localStorage.getItem('mouse_last_target'));
    let lastTarget = null;
    if (lastTargetRaw && (Date.now() - lastTargetRaw.timestamp < 10800000)) {
        lastTarget = lastTargetRaw;
    }

    let touchTimer, audioCtx;
    let gameState = 'MAP';
    let initialTotalKm = 0;

    const els = {
        distInfo: document.getElementById('dist-info'),
        startBtn: document.getElementById('start-btn'),
        mapPage: document.getElementById('map-page'),
        gamePage: document.getElementById('game-page'),
        pathGrid: document.getElementById('path'),
        locateBtn: document.getElementById('locate-btn'),
        searchContainer: document.getElementById('search-container'),
        searchInput: document.getElementById('text-search-input'),
        voiceBtn: document.getElementById('voice-btn'),
        welcomeOverlay: document.getElementById('welcome-overlay'),
        shareBtn: document.getElementById('share-btn'),
        modeBtn: document.getElementById('mode-btn'),
        actionContainer: document.querySelector('.action-container')
    };

    function initMap() {
        if(sessionStorage.getItem('introSeen')) els.welcomeOverlay.classList.add('hidden');
        map = L.map('map', { zoomControl: false, attributionControl: false }).setView([59.3, 14.1], 5);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

        if (lastTarget) {
            currentTargetName = lastTarget.name || "M√•l";
            setTarget(lastTarget.coords, false);
            map.setView(lastTarget.coords, 14); 
            initialZoomPerformed = true;
        }

        if (navigator.geolocation) {
            navigator.geolocation.watchPosition(handlePositionUpdate, null, { 
                enableHighAccuracy: true, 
                maximumAge: 5000, 
                timeout: 10000 
            });
        }

        map.on('click', e => { 
            if(gameState !== 'MAP') return;
            playClickSound(); 
            currentTargetName = "Markerad plats"; 
            setTarget(e.latlng, true); 
        });

        map.on('contextmenu', e => {
            if(gameState !== 'MAP' || !currentTargetCoords) return;
            playClickSound();
            waypoints.push(e.latlng);
            const wpMarker = L.circleMarker(e.latlng, {
                radius: 6, fillColor: "#FF9800", color: "#fff", weight: 2, opacity: 1, fillOpacity: 0.8
            }).addTo(map);
            waypointMarkers.push(wpMarker);
            updateMapLogic();
        });

        map.on('movestart', (e) => { if (!e.hard) isTracking = false; });
        setupInteractions();
        updateButtonUI();
        handleOrientationLayout();
        window.addEventListener('resize', handleOrientationLayout);
    }

    function handlePositionUpdate(pos) {
        userCoords = [pos.coords.latitude, pos.coords.longitude];
        if (!userMarker) {
            userMarker = L.circleMarker(userCoords, {radius: 8, fillColor: "#007bff", color: "#fff", weight: 2, fillOpacity: 0.8}).addTo(map);
        } else userMarker.setLatLng(userCoords);
        
        if (isTracking && gameState === 'MAP') map.panTo(userCoords);
        if (!initialZoomPerformed) { zoomToUser(); initialZoomPerformed = true; isTracking = true; }
        
        if (gameState === 'MAP') updateMapLogic();
        else if (gameState === 'GAME') updateGameLogic();
    }

    async function updateMapLogic() {
        if (!userCoords || !currentTargetCoords) return;
        
        const mode = modes[travelMode];
        let pts = [`${userCoords[1]},${userCoords[0]}`];
        waypoints.forEach(wp => pts.push(`${wp.lng},${wp.lat}`));
        pts.push(`${currentTargetCoords.lng},${currentTargetCoords.lat}`);
        if (travelMode === 2) pts.push(`${userCoords[1]},${userCoords[0]}`);

        const url = `https://router.project-osrm.org/route/v1/${mode.osrm}/${pts.join(';')}?overview=full&geometries=geojson`;
        
        try {
            const res = await fetch(url);
            const data = await res.json();
            if (data.code === 'Ok') {
                const route = data.routes[0];
                currentRouteCoords = route.geometry.coordinates.map(c => [c[1], c[0]]);
                const distKm = route.distance / 1000;
                
                if (connectionLine) connectionLine.setLatLngs(currentRouteCoords);
                else connectionLine = L.polyline(currentRouteCoords, {color: '#007bff', weight: 4, opacity: 0.6}).addTo(map);
                
                els.distInfo.innerHTML = `<b>${distKm.toFixed(2)} km</b> till ${currentTargetName}`;
                els.startBtn.classList.remove('hidden');
            } else { fallbackDist(); }
        } catch (e) { fallbackDist(); }
    }

    function fallbackDist() {
        const d = map.distance(userCoords, currentTargetCoords) / 1000;
        const total = d * (travelMode === 2 ? 2 : 1);
        currentRouteCoords = [[userCoords[0], userCoords[1]], [currentTargetCoords.lat, currentTargetCoords.lng]];
        els.distInfo.innerHTML = `<b>${total.toFixed(2)} km</b> (f√•gelv√§gen)`;
        els.startBtn.classList.remove('hidden');
    }

    // --- Resterande funktioner (startGame, moveMouse, etc.) beh√•lls men anropas av den optimerade logiken ---
    function setTarget(latlng, shouldSave) {
        waypoints = []; waypointMarkers.forEach(m => map.removeLayer(m)); waypointMarkers = [];
        currentTargetCoords = latlng;
        if (targetMarker) targetMarker.setLatLng(latlng);
        else targetMarker = L.marker(latlng).addTo(map);
        if (shouldSave) {
            localStorage.setItem('mouse_last_target', JSON.stringify({coords: latlng, name: currentTargetName, timestamp: Date.now()}));
        }
        updateMapLogic();
        updateLocateBtnText();
    }

    function zoomToUser() { if (userCoords) map.flyTo(userCoords, 16); }
    function toggleView() { 
        if (!currentTargetCoords || isShowingUser) { zoomToUser(); isShowingUser = false; isTracking = true; }
        else { map.flyTo(currentTargetCoords, 14); isShowingUser = true; isTracking = false; }
        updateLocateBtnText();
    }
    function updateLocateBtnText() { els.locateBtn.innerHTML = (!currentTargetCoords || isShowingUser) ? "üéØ HITTA MEJ" : `üèÅ ${currentTargetName.toUpperCase()}`; }
    function toggleTravelMode() { travelMode = (travelMode + 1) % modes.length; els.modeBtn.innerText = modes[travelMode].icon; updateMapLogic(); }
    function playClickSound() { if (audioCtx) { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(3000, audioCtx.currentTime); g.gain.setValueAtTime(0.05, audioCtx.currentTime); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+0.1); } }

    // Start/Game logik
    function startGame() {
        if (!currentTargetCoords || !userCoords) return;
        if (navigator.wakeLock) navigator.wakeLock.request('screen').then(lock => wakeLock = lock);
        gameState = 'GAME';
        startCoords = [...userCoords];
        const distStr = els.distInfo.innerText.split(' ')[0].replace('<b>', '').replace('</b>', '');
        initialTotalKm = Math.max(1, Math.ceil(parseFloat(distStr) / modes[travelMode].factor));
        
        els.mapPage.classList.add('hidden');
        els.gamePage.classList.remove('hidden');
        els.pathGrid.innerHTML = '<div id="the-mouse">üê≠</div>';
        for (let i = 0; i < initialTotalKm; i++) {
            const step = document.createElement('div');
            step.className = 'step'; step.id = `step-${i}`;
            step.innerHTML = (i === initialTotalKm - 1) ? 'üßÄ' : 'üçé';
            els.pathGrid.appendChild(step);
        }
        setTimeout(() => moveMouse(0), 100);
    }

    function updateGameLogic() {
        if (gameState !== 'GAME' || !currentRouteCoords.length) return;
        let minD = Infinity, idx = 0;
        currentRouteCoords.forEach((c, i) => { const d = map.distance(userCoords, c); if (d < minD) { minD = d; idx = i; } });
        
        let traveled = 0;
        for (let i = 0; i < idx; i++) traveled += map.distance(currentRouteCoords[i], currentRouteCoords[i+1]);
        
        let steps = Math.floor((traveled / 1000) / modes[travelMode].factor);
        for (let i = 0; i < initialTotalKm - 1; i++) {
            const s = document.getElementById(`step-${i}`);
            if (s) i < steps ? s.classList.add('eat-animation') : s.classList.remove('eat-animation');
        }

        const goal = (travelMode === 2) ? startCoords : currentTargetCoords;
        if (map.distance(userCoords, goal) < 40 && steps > (initialTotalKm * 0.8)) {
            moveMouse(initialTotalKm - 1); setTimeout(finishGame, 500);
        } else {
            moveMouse(Math.max(0, Math.min(steps, initialTotalKm - 2)));
        }
    }

    function moveMouse(index) {
        const m = document.getElementById('the-mouse');
        const s = document.getElementById(`step-${index}`);
        if (s) { m.style.left = s.offsetLeft + "px"; m.style.top = s.offsetTop + "px"; }
    }

    function finishGame() {
        if (gameState === 'FINISHED') return;
        gameState = 'FINISHED';
        const m = document.getElementById('the-mouse');
        m.innerHTML = 'üê≠üßÄ'; m.classList.add('victory');
        createConfetti();
    }

    function stopGame() { if (wakeLock) wakeLock.release(); gameState = 'MAP'; els.gamePage.classList.add('hidden'); els.mapPage.classList.remove('hidden'); }
    function handleOrientationLayout() { if (window.innerHeight < window.innerWidth) { els.actionContainer.prepend(els.modeBtn); } else { document.querySelector('.save-btn-container').appendChild(els.modeBtn); } }
    function toggleSearchUI() { els.searchContainer.classList.toggle('hidden'); if (!els.searchContainer.classList.contains('hidden')) els.searchInput.focus(); }
    async function executeTextSearch() {
        const q = els.searchInput.value; if (!q) return;
        const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
        const d = await res.json();
        if (d.length > 0) {
            currentTargetName = d[0].display_name.split(',')[0];
            setTarget({lat: parseFloat(d[0].lat), lng: parseFloat(d[0].lon)}, true);
            map.flyTo(currentTargetCoords, 14); els.searchContainer.classList.add('hidden');
        }
    }
    function updateButtonUI() {
        savedLocations.forEach((loc, i) => {
            const btn = document.getElementById(`btn-${i}`);
            const span = btn.querySelector('.scrolling-text');
            span.innerText = loc ? loc.name : "SPARA " + (i + 1);
            loc ? btn.classList.add('filled') : btn.classList.remove('filled');
        });
    }
    function handleSlotClick(i) { const d = savedLocations[i]; if (d) { currentTargetName = d.name; setTarget(d.coords, true); map.flyTo(d.coords, 14); } }
    function saveCurrentPos(i) { if (!currentTargetCoords) return; const l = prompt("Spara som:", currentTargetName); if (l) { savedLocations[i] = {coords: currentTargetCoords, name: l}; localStorage.setItem('mouse_favs', JSON.stringify(savedLocations)); updateButtonUI(); } }
    function setupInteractions() { document.querySelectorAll('.slot-btn').forEach((b, i) => { b.oncontextmenu = (e) => { e.preventDefault(); saveCurrentPos(i); }; }); }
    function createConfetti() { for(let i=0; i<30; i++) { const c = document.createElement('div'); c.className='confetti'; c.style.left=Math.random()*100+'vw'; c.style.backgroundColor=`hsl(${Math.random()*360},70%,50%)`; document.body.appendChild(c); setTimeout(()=>c.remove(),3000); } }
    
    window.onload = initMap;
</script>
</body>
</html>